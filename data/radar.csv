name,ring,quadrant,isNew,description
Microservice Architecture,1,Software Engineering,FALSE,"Microservice architecture is a software development approach that structures an application as a collection of loosely coupled services, each implementing a specific business function and communicating through well-defined APIs. Unlike monolithic architectures where the entire application is built as a single unit, microservices are small, independently deployable modules that work together to form the whole application. This architecture allows for greater flexibility in using different programming languages and technologies within the same application, easier scaling by deploying more instances of specific services as needed, and improved resilience, as the failure of a single service does not necessarily bring down the entire system. Microservices also support organizational agility by enabling small, cross-functional teams to own and evolve services independently, thereby accelerating development cycles and facilitating continuous delivery and deployment."
Serverless Architecture,1,Software Engineering,FALSE,"Serverless architecture is a cloud computing model that allows developers to build and run applications and services without managing the underlying infrastructure. In a serverless setup, the cloud provider dynamically manages the allocation and provisioning of servers. Developers simply deploy code, and the platform automatically handles the execution, scaling from a few requests per day to thousands per second as needed.
The term ""serverless"" doesn't mean servers are absent; rather, it means that the responsibility for managing servers and infrastructure is shifted away from the developers. This model enables developers to focus more on writing code and less on managing and operating servers or runtime environments.
Serverless architectures are often used in conjunction with event-driven programming, where code is executed in response to events such as HTTP requests, database changes, or message queue triggers. This approach can lead to cost savings, as billing is based on the actual amount of resources consumed by an application, rather than on pre-purchased units of capacity. It also promotes faster development cycles, scalability, and high availability."
Domain Driven Design,1,Software Engineering,FALSE,"Domain-Driven Design (DDD) is a methodology that centers on modeling software closely after the real-world domain it targets. It emphasizes collaboration between technical and domain experts to create a shared language, ensuring the software architecture and codebase reflect the specific complexities and rules of the domain. DDD aims to produce more intuitive and adaptable software systems by prioritizing domain logic and structures over technical details."
OpenAPI,1,Backend,FALSE,"OpenAPI, formerly known as Swagger, is a specification for building APIs that allows for a standardized way to describe RESTful APIs. This specification enables both humans and computers to understand the capabilities of a service without accessing its source code or seeing any documentation. An OpenAPI definition can then be used to generate documentation, client SDKs, and even server stubs in various programming languages. This approach facilitates API development, testing, and integration, making it easier for developers to create and consume web services. OpenAPI supports defining endpoints, request/response schemas, authentication methods, and other relevant API information, thus promoting clear communication, interoperability, and faster development cycles in the API ecosystem."
PostgreSQL,1,Backend,FALSE,"PostgreSQL is an advanced, open-source object-relational database system known for its reliability, robustness, and performance. It supports a wide range of data types, including JSON, and offers features such as sophisticated query capabilities, transactional integrity, and concurrency without read locks. PostgreSQL is designed to handle a variety of workloads, from single machines to data warehouses or Web services with many concurrent users. It provides extensive support for SQL standards and offers many modern features: complex queries, foreign keys, triggers, updatable views, and stored procedures. Its extensibility makes it a popular choice for developers who need a secure, scalable, and efficient database solution for their applications."
Serverless Functions,1,Backend,FALSE,"Serverless functions, often referred to as Functions as a Service (FaaS), are small, single-purpose pieces of code that are executed in response to events, such as HTTP requests, database events, or queue messages. In a serverless architecture, the cloud provider automatically manages the execution environment, scaling up or down based on demand. Developers write and deploy code, which the cloud provider then executes, handles, and scales as needed, charging only for the compute time used during the function execution. This model allows for highly scalable, efficient applications without the need to manage server infrastructure, leading to cost savings and reduced operational overhead for developers."
OAuth og OpenID Connect,1,Backend,FALSE,"OAuth is an open standard for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords. It acts as an intermediary, providing tokens to applications after the user has approved access. This allows users to share their data from one site (like a social network or cloud storage) with another site or application without sharing their credentials.

OpenID Connect (OIDC) is built on top of OAuth 2.0 and adds an authentication layer, enabling clients to verify the identity of the end-user based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the end-user in an interoperable and REST-like manner. OIDC allows clients to request and receive information about authenticated sessions and end-users. In essence, while OAuth 2.0 is about resource access and sharing, OIDC is about user authentication."
REST API,1,Backend,FALSE,"A REST API is a way for web applications to communicate with each other using standard HTTP methods, allowing clients to access and manipulate web resources through URLs and HTTP protocols. It's designed for simplicity, scalability, and stateless communication."
NoSQL,1,Backend,FALSE,"NoSQL is a category of database management systems that differ from traditional relational database systems in that they do not use SQL for querying. NoSQL databases are designed to handle large volumes of data, provide high performance, and scale easily. They are often used for big data and real-time web applications. NoSQL databases can store data in various formats such as key-value pairs, document-oriented, column-oriented, or graph databases, making them more flexible in handling different data types and structures compared to the strict schemas required by relational databases. This flexibility allows NoSQL databases to efficiently manage unstructured or semi-structured data.

E.g. DynamoDB, MongoDB, Redis, Elasticsearch, Neo4j, key value storage"
Relasjonsdatabaser,1,Backend,FALSE,"A relational database is a type of database that stores and provides access to data points that are related to one another. It organizes data into tables, which consist of rows and columns, with each row representing a record and each column representing a data field. Relational databases use Structured Query Language (SQL) for defining, manipulating, and querying data. They are based on the relational model, an intuitive and straightforward way of representing data in tables. This model enables complex queries and transactions, ensuring data integrity and consistency through constraints, relationships, and transactions. Relational databases are widely used for a variety of applications, from simple customer relationship management systems to complex financial systems, due to their reliability, flexibility, and robust support for concurrent users and transactions."
Unit-testing,1,Backend,FALSE,"Unit testing is a software testing method where individual units or components of a software application are tested in isolation to ensure that each part functions correctly. A ""unit"" can refer to a function, method, procedure, module, or object in object-oriented programming. The primary goal of unit testing is to validate that each unit of the software performs as designed. This testing is typically done by developers themselves using automated testing frameworks, which allows for tests to be run frequently and consistently. Unit testing helps identify bugs early in the development cycle, simplifies code refactoring, and serves as documentation for the codebase. It is a fundamental practice in agile and test-driven development methodologies.

See Junit, Kotest, Mockk, Mockito"
Integration-testing,1,Backend,FALSE,"In the context of modern software development practices, particularly those following Agile, DevOps, or CI/CD methodologies, integration testing is an ongoing, integrated process rather than a discrete phase. It involves continuously testing the interaction between different parts of the application as soon as they are developed and combined. This approach aims to quickly identify and fix integration issues, facilitating smoother and more efficient development cycles.

In these environments, automation plays a crucial role. Automated integration tests are run as part of the build pipeline, triggered by code commits or merges into shared repositories. This ensures that integration issues are detected early and can be addressed immediately, reducing the risk of significant problems later in the development cycle.

Moreover, modern practices encourage smaller, more frequent updates to software, which necessitates a robust suite of automated tests to verify that new changes integrate well with existing functionality. This approach to integration testing supports a faster feedback loop, enhances collaboration among developers, testers, and operations teams, and leads to higher quality software being developed and released at a quicker pace."
Docker,1,Backend,FALSE,"Docker is an open-source platform that automates the deployment of applications inside lightweight, portable containers. Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and ship it all out as one package. By doing so, Docker ensures that the application will run on any other Linux machine regardless of any customized settings that machine might have that could differ from the machine used for writing and testing the code. This approach simplifies the complexities of deploying and running software across different environments, ensuring consistency and efficiency. Docker containers are isolated from each other and the host system, but they can communicate with each other through well-defined channels. Docker is widely used in the development, shipping, and running of applications, facilitating continuous integration and deployment processes."
Java,1,Backend,FALSE,Nyere Java v 11 og oppover.
"Kotlin ",1,Backend,FALSE,
Spring Boot,1,Backend,FALSE,webframework - Både Spring Boot 2 og 3.
Micronaut,1,Backend,FALSE,
Serverless Functions,1,Backend,FALSE,"AWS Lambda, etc."
Key Value Storage,1,Backend,FALSE,"Redis, in-memory cache database"
Trunk-based development,1,Software Engineering,FALSE,"Trunk-based development is a software development strategy where all developers commit code changes to a single branch in the version control system, often referred to as the ""trunk"" or ""main"" branch. This approach emphasizes short-lived feature branches (if they are used at all), which are merged back into the trunk frequently, ideally at least once a day. The goal of trunk-based development is to minimize the divergence of code among different branches, facilitating continuous integration, reducing merge conflicts, and enabling faster release cycles. By encouraging small, incremental changes to the codebase and regular integrations, trunk-based development helps maintain a high level of code quality and accelerates the feedback loop between developers and users."
"Testing (Unit, integration, performance, …)",1,Software Engineering,FALSE,
Cloud Native,1,Software Engineering,FALSE,"Cloud-native refers to a set of practices and technologies used for building and running applications to take full advantage of cloud computing models. This approach emphasizes scalable, elastic, and fault-tolerant designs that leverage managed services. Cloud-native development typically involves using microservices architecture, containers, service meshes, immutable infrastructure, and declarative APIs. These practices enable organizations to rapidly deploy, update, and scale applications across public, private, and hybrid clouds. Cloud-native approaches foster agility, resilience, and portability across cloud environments, facilitating continuous integration and continuous delivery (CI/CD) processes for faster development cycles and more robust systems."
Container orchestration,1,Backend,FALSE,"Container orchestration is the automated management, scaling, and networking of containers. Containers, which are lightweight, standalone packages containing everything needed to run a piece of software, can be deployed across various environments in a consistent manner. Orchestration tools help in managing the lifecycle of containers, especially in large, dynamic environments. This includes automating deployment, scaling containers up or down based on demand, managing container health, networking between containers, and ensuring there is a consistent environment for the application to run. Popular tools like Kubernetes, Docker Swarm, and Apache Mesos facilitate container orchestration, allowing for the efficient handling of containerized applications at scale. This is crucial for supporting microservices architectures and DevOps practices, where the ability to quickly deploy, scale, and manage containers can significantly impact development cycles and application resilience.

E.g. Openshift, Kubernetes, Fargate"
pgvector,3,Backend,TRUE,"With the rise of Generative AI-powered applications, we see a pattern of storing and efficiently searching https://www.featureform.com/post/the-definitive-guide-to-embeddings vectors for similarities. https://github.com/pgvector/pgvector is an open-source vector similarity search extension for PostgreSQL.

"
Pinecone,3,Backend,TRUE,"https://www.pinecone.io/ is a fully managed, developer-friendly and cloud-native vector database with a simple API and no infrastructure hassles. Pinecone serves filtered query results with low latency at the scale of billions of vectors.

"
Retrieval-augmented generation (RAG),3,Software Engineering,TRUE,"https://arxiv.org/abs/2005.11401v4 is a pattern to improve the quality of responses generated by a large language model (LLM). With RAG, information about relevant and trustworthy documents — in formats like HTML and PDF — are stored in databases that supports a vector data type or efficient document search, such as https://www.thoughtworks.com/radar/platforms/pgvector, https://www.thoughtworks.com/radar/platforms/qdrant or https://www.thoughtworks.com/radar/platforms/elasticsearch-relevance-engine. For a given prompt, the database is queried to retrieve relevant documents, which are then combined with the prompt to provide richer context to the LLM. This results in higher quality output and greatly reduced hallucinations. The context window — which determines the maximum size of the LLM input — is limited, which means that selecting the most relevant documents is crucial. We improve the relevancy of the content that is added to the prompt by reranking. Similarly, the documents are usually too large to calculate an embedding, which means they must be split into smaller chunks. This is often a difficult problem, and one approach is to have the chunks overlap to a certain extent.

"
promptfoo,3,Backend,TRUE,"https://github.com/promptfoo/promptfoo enables test-driven https://www.thoughtworks.com/radar/techniques/prompt-engineering. While integrating LLMs in applications, tuning of the prompts to produce optimal, consistent outputs can be time-consuming. You can use promptfoo both as a CLI and a library to systematically test prompts against predefined test cases. The test case, along with assertions, can be set up in a simple YAML config file. This config includes the prompts being tested, the model provider, the assertions and the variable values that will be substituted in the prompts. promptfoo supports many assertions, including checking for equality, JSON structure, similarity, custom functions or even using an LLM to grade the model outputs. If you're looking to automate feedback on prompt and model quality, do assess promptfoo.

"
Event Driven Architecture,2,Software Engineering,FALSE,"Event-driven architecture (EDA) is a software design pattern in which components or services of the application are triggered by events. These events can be actions by users, system triggers, or messages from other services. In an EDA, events are emitted by event producers (which don't necessarily know what will be done with the event) and are handled by event consumers (which perform actions in response to the event, but don't necessarily know where the event came from). This architecture promotes loose coupling between components, enabling more scalable, flexible, and resilient systems. It's particularly well-suited for asynchronous operations, microservices architectures, and real-time data processing applications. EDA facilitates the development of highly responsive systems that can easily adapt to changes or spikes in demand, by efficiently managing and reacting to streams of event data."
Observability & monitoring,2,Software Engineering,FALSE,"Monitoring is the practice of collecting, analyzing, and displaying data about the system's operational state. It typically involves predefined metrics and logs that indicate the health of the system, such as CPU usage, memory consumption, and request response times. Monitoring tools alert teams to problems or anomalies that could indicate issues needing immediate attention.

Observability, on the other hand, is a broader concept that encompasses monitoring but also includes the ability to explore and understand the system's state, especially in complex systems. It involves gathering detailed data like metrics, logs, and traces, which provide insights into the inner workings of the system and its performance. Observability allows teams to diagnose and solve problems that were not anticipated, by understanding how the system behaves and how its components interact.

See OpenTelemetry, APM, distibuted tracing"
Performance-testing,2,Backend,FALSE,"Performance testing is a type of software testing aimed at determining how a system performs in terms of responsiveness and stability under a certain load. It involves simulating real-life user load scenarios to test the speed, scalability, and reliability of software applications. Performance testing can identify bottlenecks, measure response times, throughput rates, resource utilization levels, and endurance under sustained use. The goal is to ensure that the software meets the performance criteria and provides a good user experience under various conditions. This testing is crucial for identifying and mitigating performance issues before a product goes live, helping to avoid potential downtimes and ensuring the system can handle expected traffic volumes."
Quarkus,2,Backend,FALSE,webframework
NewSQL,2,Backend,FALSE,"NewSQL is a class of modern relational database management systems that seek to provide the same scalable performance of NoSQL systems for online transaction processing (OLTP) workloads while maintaining the ACID guarantees (Atomicity, Consistency, Isolation, Durability) of a traditional SQL database. NewSQL databases are designed to overcome the limitations of traditional SQL databases in handling large volumes of transactions and data, particularly in distributed computing environments. They often employ innovative architectures, such as distributed systems designs, to achieve high scalability, fault tolerance, and concurrency control, without sacrificing the relational model and the ability to use SQL for queries. This makes NewSQL an attractive option for businesses that require the robust data integrity features of relational databases but also need to scale out to meet high performance demands."
GraphQL,2,Backend,FALSE,"GraphQL is a query language for APIs and a runtime for executing those queries by using a type system you define for your data. Unlike traditional REST APIs that require loading from multiple URLs, GraphQL enables clients to request exactly what they need, not more, not less. It allows clients to aggregate data from multiple sources with a single API call. The server then returns JSON formatted precisely as requested, making data retrieval more efficient. GraphQL queries access not just the properties of one resource but also smoothly follow references between them. GraphQL has gained popularity for its efficiency and flexibility, offering a powerful alternative to the REST architectural style for developing web APIs."
Graph Databaser,2,Backend,FALSE,"A graph database is a type of NoSQL database designed to store, map, and query relationships between entities efficiently. It uses graph structures with nodes (entities), edges (relationships), and properties to represent and store data. The key feature of a graph database is its ability to perform complex queries and traverse deep relationships between data points rapidly, making it ideal for scenarios where relationships are highly interconnected, such as social networks, recommendation systems, and network analysis. Unlike relational databases that require JOIN operations to relate tables, graph databases directly store the relationships, allowing for quicker and more intuitive queries regarding the connections within the data. This leads to performance benefits and easier data modeling in applications where relationships are a central aspect of the data.

See: Neptune, Neo4j."
Python,2,Backend,FALSE,Python er et språk som brukes overalt i AWS of ellers
API Gateway,2,Backend,FALSE,
Feature Toggles,2,"Backend, Frontend",FALSE,"Feature toggles, also known as feature flags, are a software development technique that allows teams to modify system behavior without changing code. By wrapping a new or existing feature in a toggle, developers can enable or disable that feature at runtime, typically through a configuration change. This technique is used to facilitate a range of practices, such as A/B testing, canary releases, continuous deployment, and enabling trunk-based development by allowing features to be merged into the main branch even if they aren't ready to be released to end-users. Feature toggles provide a powerful way to gradually roll out features, test in production, and quickly revert changes if issues arise, all without deploying new code. They enable more flexible control over the software's functionality and user experience but require careful management to avoid technical debt associated with having too many toggles."
GraalVM,2,Backend,FALSE,"GraalVM is a high-performance universal virtual machine that supports multiple languages and execution modes, including just-in-time (JIT) compilation and ahead-of-time (AOT) compilation, known as native compilation. It aims to improve the performance and efficiency of Java applications and also supports other programming languages like JavaScript, Ruby, and Python.

Native compilation, a key feature of GraalVM, involves compiling Java bytecode into a standalone executable binary. This process translates the application into machine code for a specific target architecture before it's run, rather than interpreting or JIT compiling the bytecode at runtime. The resulting native binary has faster startup times and reduced memory footprint compared to running in a traditional JVM, making it particularly suitable for cloud-native environments, microservices, and serverless computing where efficiency and quick startup times are crucial. GraalVM's ability to perform cross-language optimization further enhances performance, allowing developers to seamlessly integrate and optimize code across different programming languages."
Test Driven Development,2,Software Engineering,FALSE,"Test-Driven Development (TDD) is a software development approach where tests are written before the actual code. The process follows a short, repetitive cycle: First, write a test for the next bit of functionality you want to add. The test should fail since the functionality doesn't exist yet. Next, write the minimal amount of code necessary to make the test pass. Finally, refactor the code to improve its structure and clarity, ensuring all tests still pass. This cycle is often summarized as red (write a failing test), green (make the test pass), and refactor (clean up the code). TDD encourages simple designs and inspires confidence in the software's functionality, as new features are developed with tests confirming they work as intended from the start."
Soft skills,2,Software Engineering,FALSE,
Architecture patterns and why they work for what,2,Software Engineering,FALSE,
Arkitekturmål og målarkitektur,2,Software Engineering,FALSE,
Helsiktig / generell domene innsikt,2,Software Engineering,FALSE,
Data as first class citizen,3,Software Engineering,FALSE,"Data as a first-class citizen in software engineering and data science is a concept emphasizing the importance of data quality, accessibility, and interoperability in systems and applications. This approach treats data with the same priority as code functionality, meaning that data is carefully designed, managed, and utilized to ensure it is accurate, available, and usable across different parts of an application or system. By prioritizing data in this manner, organizations can better leverage their data for decision-making, ensure consistency and reliability across services, and create more adaptable and scalable systems. The idea encourages practices such as comprehensive data governance, effective data management strategies, and the use of standards to ensure data can be easily shared and processed across different platforms and environments."
.NET 6+,3,Backend,FALSE,Framework
Edge Computing,3,"Backend, Frontend",FALSE,"Edge computing is a distributed computing paradigm that brings computation and data storage closer to the location where it is needed, to improve response times and save bandwidth. Unlike traditional cloud computing architectures that centralize processing in data centers, edge computing processes data near the source of data generation, such as IoT devices, smartphones, or edge servers located near users. This approach reduces latency, enhances the speed of data processing, and allows for real-time data analysis and decision-making. Edge computing is particularly beneficial in scenarios where quick processing is critical or where connectivity to a central server is limited or expensive. It supports a wide range of applications, from autonomous vehicles and smart cities to industrial IoT and augmented reality, enabling more efficient and intelligent systems."
HashiCorp Nomad,3,Backend,FALSE,"HashiCorp Nomad is a flexible workload orchestrator that enables organizations to deploy, manage, and scale applications across on-premises and cloud environments with ease. It supports containerized, virtualized, and standalone applications and can run on Linux, Windows, and macOS. Nomad uses a declarative job specification to deploy applications, which simplifies the process of application deployment and management. It is designed for simplicity and supports high availability, scalability, and multi-datacenter and multi-region deployments. Nomad integrates seamlessly with other HashiCorp tools like Consul for service networking and Vault for secrets management, providing a comprehensive solution for infrastructure automation and application deployment. Its ability to schedule and orchestrate a diverse range of workloads makes it a versatile tool for developers and operations teams looking to efficiently manage their infrastructure"
AI driven discovery,3,"Backend, Metodikk og prosess",FALSE,"AI kan ofte hjelpe med trege og slitsomme oppgaver som å søke etter og lese gjennom masse dokumentasjon. "
Tidsseriedatabaser,3,Backend,FALSE,"A time series database (TSDB) is a type of database optimized for storing and querying sequences of data points indexed by time. It's specifically designed to handle time-stamped or time-series data — data that changes over time or is measured at successive points in time. This includes a wide range of data types, such as metrics from IoT devices, application performance monitoring data, financial trading data, and many others.

Time series databases are built to efficiently collect, store, and query large volumes of temporal data, providing fast data ingestion rates and optimized queries for time-based analytics. They support time-based queries, aggregation, and analysis across time intervals, making it easier to identify trends, patterns, and anomalies over time. TSDBs are particularly useful in contexts requiring high write volumes and rapid queries over time-stamped data, such as monitoring systems, real-time analytics platforms, and historical data analysis tools. Their ability to handle the scale and specificity of temporal data makes them a crucial component in modern data infrastructure for time-sensitive applications."
Deno,3,"Backend, Frontend",FALSE,Runtime
Bun,3,"Backend, Frontend",FALSE,Runtime
AsyncAPI,3,Backend,FALSE,"AsyncAPI is an open-source initiative that provides a specification and a suite of tools to describe and work with asynchronous APIs. It aims to standardize the definition of asynchronous APIs, much like OpenAPI does for synchronous REST APIs. Asynchronous communication is common in event-driven architectures, where services communicate through events rather than direct requests and responses."
CockroachDB,3,Backend,FALSE,NoSQL DB
OpenJDK CRaC,3,Backend,FALSE,"OpenJDK CRaC (Coordinated Restore at Checkpoint) is an open-source project under the OpenJDK umbrella, aimed at enhancing Java applications' startup time and performance. CRaC focuses on the concept of ""checkpoint/restore"": it allows a Java Virtual Machine (JVM) to take a snapshot (checkpoint) of a running application's state and then restore from that snapshot in the future. This capability significantly reduces startup times because the application can be quickly restarted from a checkpointed state rather than being initialized from scratch.

The project targets scenarios where rapid startup times are crucial, such as in cloud environments, serverless architectures, or microservices, where applications need to scale dynamically in response to varying loads. By enabling faster restarts, CRaC contributes to more efficient resource utilization and improved responsiveness of Java applications in these contexts. The CRaC project complements existing Java features and optimizations, offering a novel approach to reducing startup latency and enhancing overall application performance.

E.g. AWS Lambda SnapStart"
Rust,3,Backend,FALSE,Language
Draw.io,3,Software Engineering,FALSE,
C4 model,3,Software Engineering,FALSE,
Archimate,3,Software Engineering,FALSE,"ArchiMate is a standardized modeling language for enterprise architecture, providing tools for describing, analyzing, and visualizing relationships across business, application, and technology layers in a clear and integrated way."
Continuous Discovery,3,Software Engineering,FALSE,"Continuous discovery is an iterative process in agile product development where teams regularly engage with customers or users to gather insights about their needs, problems, and behaviors. This ongoing interaction helps inform and refine product features, priorities, and roadmap decisions. By continuously integrating user feedback and data into the development cycle, teams can better align their products with user expectations and market demands, ensuring that the product evolves in a way that delivers real value. Continuous discovery emphasizes learning and adapting quickly, allowing teams to respond to changes and opportunities more effectively and reduce the risk of developing features or products that don't meet user needs."
Data mesh,3,Software Engineering,FALSE,"Data mesh is a decentralized approach to data architecture and organizational design, intended to overcome the limitations of traditional data management strategies that can struggle with scale, complexity, and agility in large organizations. It treats data as a product, emphasizing domain-oriented ownership and accountability. In a data mesh, data is managed and governed by the domain teams that produce it, making data more accessible and useful across the organization. This approach promotes interoperability through a standardized communication protocol and encourages a culture of collaboration and self-service analytics. Data mesh aims to create a scalable and flexible data architecture that supports rapid, data-driven decision-making and innovation by breaking down silos and democratizing data access."
"Jakarta EE ",4,Backend,FALSE,Gamle Java EE donert til Eclipse foundation.
Java backends uten webrammeverk,4,Backend,FALSE,
Java (gammel),4,Backend,FALSE,Java v 7- 11 legacy java.
JUnit 4,4,Backend,FALSE,Test Framework
Groovy,4,Backend,FALSE,Language
Grails,4,Backend,FALSE,Web Framework
